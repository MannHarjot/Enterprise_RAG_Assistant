{
  "filename": "4SD3_W26_assignment1.pdf",
  "chunks": [
    {
      "filename": "4SD3_W26_assignment1.pdf",
      "page": 1,
      "chunk_id": 1,
      "text": "COMPSCI 4SD3 Data-Driven Algorithms for Sequential Decision Making Assignment 1 Winter 2026 Sivan Sabato, McMaster University Due Date: See Avenue to Learn • Submit on the course’s Avenue to Learn website. • The answers to all the questions (including questions about the code part) must be typeset in Latex and submitted as a single pdf file (call it assignment.pdf). Submit the pdf file into the “questions part” assignment component in A2L. • The code for the programming task (Question 3 below) must be submitted as a single Python file (call it assignment1.py) into the “code part” assignment component in A2L. • This assignment is worth 10% of the final course grade. • For questions about the assignment, use the “Q and A” channel on the course Teams. • This is an individual assignment. Each student should solve and submit it on their own. • Use of generative AI for assignments is strictly forbidden in this course, and will be con- sidered a violation of academic integrity. 1. [15 points]"
    },
    {
      "filename": "4SD3_W26_assignment1.pdf",
      "page": 1,
      "chunk_id": 2,
      "text": " Use of generative AI for assignments is strictly forbidden in this course, and will be con- sidered a violation of academic integrity. 1. [15 points] Answer the following questions using Hoeffding’s inequality and our adaptation to a general reward range. (a) Arm a has rewards in the range [0 , 10]. We pull arm a 32 times. We use Hoeffding’s inequality to guarantee that the probability that |ˆµa(n) − µa| < ϵ is at least 90%. What is the smallest value of ϵ that would make the statement above hold? (b) Arm b has rewards in the range [0 , 1]. The expected reward of arm b is µb = 0.5. We want to pull the arm m times, such that with a probability of at least 97%, ˆµb(n) ≤ 0.7. What is the smallest m that we can use? (c) There are three arms a1, a2, a3. The arms have reward ranges [0 , 1], [0 , 2], and [0 , 4] re- spectively. We want to pull each arm m times, such that the following event holds with probability at least 93%: ∀i ∈ {1, 2, 3}, |ˆµai(n) − µai | < 0.1. What is the smallest m we"
    },
    {
      "filename": "4SD3_W26_assignment1.pdf",
      "page": 1,
      "chunk_id": 3,
      "text": "each arm m times, such that the following event holds with probability at least 93%: ∀i ∈ {1, 2, 3}, |ˆµai(n) − µai | < 0.1. What is the smallest m we can use? 2. [28 points] In the algorithm “successive elimination with known gaps”, consider the following scenario: α = 4, δ0 = 0.05, µa1 = 3, µa2 = 2, µa3 = 1.9, µa4 = 1.8. In the questions below, assume that the input to the algorithm specifies the true gaps ∆ 2, . . . ,∆4. In addition, assume that in each round i, |ˆµ(i) a1 − µa1 | < ϵ i and |ˆµ(i) ji − µji | < ϵ i, where ji is the arm with the smallest expected reward that is still in S in round i. 1"
    },
    {
      "filename": "4SD3_W26_assignment1.pdf",
      "page": 2,
      "chunk_id": 1,
      "text": "(a) How many arm pulls will occur in round 1 for each arm in S? (b) Prove that a1 is not eliminated in round 1. (c) Will arm 4 necessarily be eliminated in round 1? Explain why or why not. (d) How many arm pulls will occur in round 2 for each arm in S? (e) Prove that a1 is not eliminated in round 2. (f) In Round 3, which arms (if any) are definitely in S? Explain. (g) Which arms (if any) are definitely not in S? Explain. 3. [7 points] In successive elimination with unknown gaps, prove that if the “bad events” that we defined in class do not occur and t > 8 · α2 ln(2/δt) ∆2 i , then arm i is eliminated by round t. 4. [30 points] Programming task; You do not need to include anything as answer to this question in your submitted pdf file. Only submit the Python file to the “code part” of the assignment (see submission instructions in the box above). Implement two algorithms that we learned in class: (a) The uniform sampling algorithm (b) The successive elimination algorithm with known gaps"
    },
    {
      "filename": "4SD3_W26_assignment1.pdf",
      "page": 2,
      "chunk_id": 2,
      "text": "above). Implement two algorithms that we learned in class: (a) The uniform sampling algorithm (b) The successive elimination algorithm with known gaps. Technical instructions: • Download the necessary files from the coding assignment component on A2L. • Read the README.pdf file. Follow the instructions there to set up a python environment with the correct package versions, so that your code runs correctly when we test it on our system. • Each of the algorithms should be implemented as a function. The provided fileassignment1.py lists the required function declarations. You need to fill in the missing code. • In addition to the algorithm input parameters that we learned in class, the functions you will implement include an additional integer parameter called pull reduction. Its default value should be 1. When this parameter is 1, the algorithm runs just as we learned in class. When this parameter is larger than 1, you should divide all of the numbers of pulls that the algorithm calculat"
    },
    {
      "filename": "4SD3_W26_assignment1.pdf",
      "page": 2,
      "chunk_id": 3,
      "text": "ithm runs just as we learned in class. When this parameter is larger than 1, you should divide all of the numbers of pulls that the algorithm calculates by this value. For instance, if the algorithm calculated that you need to pull an arm 36 times, and pull reduction is 3, then you should pull the arm only 36/3 = 12 times. If the result is not an integer, you should use the ceiling of the result. • Before submitting your code, make sure usage example.py runs correctly when combined with your submitted file assignment1.py and the provided file multi armed bandit.py, which implements the arm pulls. This is a basic check to verify that you have followed the required definitions. • The run of usage example.py with your implementation should take well under a second. • Do not count on usage example.py as the only test. Test your code in difference scenarios to make sure it works correctly. • You can use the functions get true mean for each arm in your tests to verify that your algorithm wor"
    },
    {
      "filename": "4SD3_W26_assignment1.pdf",
      "page": 2,
      "chunk_id": 4,
      "text": "ence scenarios to make sure it works correctly. • You can use the functions get true mean for each arm in your tests to verify that your algorithm works well, but you are not allowed to use them in your submitted code. 5. [20 points] Run each of the two algorithms that you implemented in the previous question on the following set of arms: 1. Bernoulli, p = 0.42 2"
    },
    {
      "filename": "4SD3_W26_assignment1.pdf",
      "page": 3,
      "chunk_id": 1,
      "text": "2. Bernoulli, p = 0.43 3. Normal distribution with µ = 15.2 and σ = 2.5. 4. Normal distribution with µ = 16 and σ = 1. 5. Uniform on [0 , 2.5] 6. Uniform on [1 .24, 1.26] (a) What input arguments (other than the list of arms) do you need to provide each algorithm to find the best arm with a probability at least 0 .8? Explain the calculation of each value. (b) Run each algorithm with the above input arguments. What was the number of pulls for each algorithm? Which one was smaller and why? (c) Run each algorithm with the above input arguments 100 times. For each algorithm, what was the percent of successful runs, in which the algorithms provided the best arm? Was it more or less than the value you expected? Explain what could be the reason for the difference. (d) Run the algorithms 100 times again, this time setting pull reduction = 34. For each algorithm, what was the percent of successful runs, where the algorithms provided the best arm? What can you conclude about the formulas that th"
    },
    {
      "filename": "4SD3_W26_assignment1.pdf",
      "page": 3,
      "chunk_id": 2,
      "text": " each algorithm, what was the percent of successful runs, where the algorithms provided the best arm? What can you conclude about the formulas that the algorithms are using for the number of required arm pulls? (e) [Bonus question: 5 additional points] When you ran the successive elimination algo- rithm 100 times with pull reduction = 1, when the algorithm was successful, did it always remove the arms in the order from the worst to the best? Describe what you observed and explain what you think was the reason for this. 3"
    }
  ]
}
{
  "filename": "4SD3_W26_assignment1.pdf",
  "pages": [
    {
      "page": 1,
      "text": "COMPSCI 4SD3\nData-Driven Algorithms for Sequential Decision Making\nAssignment 1\nWinter 2026\nSivan Sabato, McMaster University\nDue Date: See Avenue to Learn\n• Submit on the course’s Avenue to Learn website.\n• The answers to all the questions (including questions about the code part) must be typeset\nin Latex and submitted as a single pdf file (call it assignment.pdf). Submit the pdf file into\nthe “questions part” assignment component in A2L.\n• The code for the programming task (Question 3 below) must be submitted as a single Python\nfile (call it assignment1.py) into the “code part” assignment component in A2L.\n• This assignment is worth 10% of the final course grade.\n• For questions about the assignment, use the “Q and A” channel on the course Teams.\n• This is an individual assignment. Each student should solve and submit it on their own.\n• Use of generative AI for assignments is strictly forbidden in this course, and will be con-\nsidered a violation of academic integrity.\n1. [15 points] Answer the following questions using Hoeffding’s inequality and our adaptation to\na general reward range.\n(a) Arm a has rewards in the range [0 , 10]. We pull arm a 32 times. We use Hoeffding’s\ninequality to guarantee that the probability that |ˆµa(n) − µa| < ϵ is at least 90%.\nWhat is the smallest value of ϵ that would make the statement above hold?\n(b) Arm b has rewards in the range [0 , 1]. The expected reward of arm b is µb = 0.5. We want\nto pull the arm m times, such that with a probability of at least 97%, ˆµb(n) ≤ 0.7. What is\nthe smallest m that we can use?\n(c) There are three arms a1, a2, a3. The arms have reward ranges [0 , 1], [0 , 2], and [0 , 4] re-\nspectively. We want to pull each arm m times, such that the following event holds with\nprobability at least 93%:\n∀i ∈ {1, 2, 3}, |ˆµai(n) − µai | < 0.1.\nWhat is the smallest m we can use?\n2. [28 points] In the algorithm “successive elimination with known gaps”, consider the following\nscenario: α = 4, δ0 = 0.05, µa1 = 3, µa2 = 2, µa3 = 1.9, µa4 = 1.8. In the questions below, assume\nthat the input to the algorithm specifies the true gaps ∆ 2, . . . ,∆4. In addition, assume that in\neach round i,\n|ˆµ(i)\na1 − µa1 | < ϵ i and |ˆµ(i)\nji − µji | < ϵ i,\nwhere ji is the arm with the smallest expected reward that is still in S in round i.\n1"
    },
    {
      "page": 2,
      "text": "(a) How many arm pulls will occur in round 1 for each arm in S?\n(b) Prove that a1 is not eliminated in round 1.\n(c) Will arm 4 necessarily be eliminated in round 1? Explain why or why not.\n(d) How many arm pulls will occur in round 2 for each arm in S?\n(e) Prove that a1 is not eliminated in round 2.\n(f) In Round 3, which arms (if any) are definitely in S? Explain.\n(g) Which arms (if any) are definitely not in S? Explain.\n3. [7 points] In successive elimination with unknown gaps, prove that if the “bad events” that we\ndefined in class do not occur and\nt > 8 · α2 ln(2/δt)\n∆2\ni\n,\nthen arm i is eliminated by round t.\n4. [30 points] Programming task; You do not need to include anything as answer to this question\nin your submitted pdf file. Only submit the Python file to the “code part” of the assignment\n(see submission instructions in the box above).\nImplement two algorithms that we learned in class:\n(a) The uniform sampling algorithm\n(b) The successive elimination algorithm with known gaps.\nTechnical instructions:\n• Download the necessary files from the coding assignment component on A2L.\n• Read the README.pdf file. Follow the instructions there to set up a python environment\nwith the correct package versions, so that your code runs correctly when we test it on our\nsystem.\n• Each of the algorithms should be implemented as a function. The provided fileassignment1.py\nlists the required function declarations. You need to fill in the missing code.\n• In addition to the algorithm input parameters that we learned in class, the functions you\nwill implement include an additional integer parameter called pull reduction. Its default\nvalue should be 1. When this parameter is 1, the algorithm runs just as we learned in class.\nWhen this parameter is larger than 1, you should divide all of the numbers of pulls that\nthe algorithm calculates by this value. For instance, if the algorithm calculated that you\nneed to pull an arm 36 times, and pull reduction is 3, then you should pull the arm only\n36/3 = 12 times. If the result is not an integer, you should use the ceiling of the result.\n• Before submitting your code, make sure usage example.py runs correctly when combined\nwith your submitted file assignment1.py and the provided file multi armed bandit.py,\nwhich implements the arm pulls. This is a basic check to verify that you have followed the\nrequired definitions.\n• The run of usage example.py with your implementation should take well under a second.\n• Do not count on usage example.py as the only test. Test your code in difference scenarios\nto make sure it works correctly.\n• You can use the functions get true mean for each arm in your tests to verify that your\nalgorithm works well, but you are not allowed to use them in your submitted code.\n5. [20 points] Run each of the two algorithms that you implemented in the previous question on\nthe following set of arms:\n1. Bernoulli, p = 0.42\n2"
    },
    {
      "page": 3,
      "text": "2. Bernoulli, p = 0.43\n3. Normal distribution with µ = 15.2 and σ = 2.5.\n4. Normal distribution with µ = 16 and σ = 1.\n5. Uniform on [0 , 2.5]\n6. Uniform on [1 .24, 1.26]\n(a) What input arguments (other than the list of arms) do you need to provide each algorithm\nto find the best arm with a probability at least 0 .8? Explain the calculation of each value.\n(b) Run each algorithm with the above input arguments. What was the number of pulls for\neach algorithm? Which one was smaller and why?\n(c) Run each algorithm with the above input arguments 100 times. For each algorithm, what\nwas the percent of successful runs, in which the algorithms provided the best arm? Was\nit more or less than the value you expected? Explain what could be the reason for the\ndifference.\n(d) Run the algorithms 100 times again, this time setting pull reduction = 34. For each\nalgorithm, what was the percent of successful runs, where the algorithms provided the best\narm? What can you conclude about the formulas that the algorithms are using for the\nnumber of required arm pulls?\n(e) [Bonus question: 5 additional points] When you ran the successive elimination algo-\nrithm 100 times with pull reduction = 1, when the algorithm was successful, did it always\nremove the arms in the order from the worst to the best? Describe what you observed and\nexplain what you think was the reason for this.\n3"
    }
  ]
}